using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using FlexUI.Animations;
using UnityEngine;
using UnityEngine.UI;

namespace FlexUI
{
	public abstract class BaseView : MonoBehaviour, IBaseViewInternal
	{
		public ViewAnimations Animations = new ViewAnimations();
		public ViewSounds Sounds = new ViewSounds();

		/// <summary>Show the view at start of scene </summary>
		public bool IsShowAtStart;

		/// <summary>Auto hide opened neighbor views inside my parent</summary>
		public bool IsHideNeighborsOnShow;

		/// <summary>When it is closing - hide all children views</summary>
		public bool IsHideChildrenOnHide = true;

		/// <summary> True if the view is manually created from prefab </summary>
		public bool IsDynamicallyCreated = false;

		/// <summary> Drag and Drop enable </summary>
		public bool IsDragMode = false;

		/// <summary> Drag and Drop mode for the view </summary>
		public DragMode DragMode = DragMode.Move;

		/// <summary> Button pressing causes OnChanged method </summary>
		public bool IsButtonsCallOnChanged = false;

		/// <summary> Do not pass gestures to owners </summary>
		public bool SuppressAnyGesturesForOwners = false;

		/// <summary>Logical visibility of the view</summary>
		public VisibleState VisibleState => visibleState;

		/// <summary>Current owner of the view</summary>
		public BaseView Owner { get; set; }

		/// <summary>Currently opened children of the view</summary>
		public List<BaseView> OpenedChildren { get; private set; } = new List<BaseView>();

		/// <summary>Data is changed</summary>
		public event Action Changed = delegate { };

		/// <summary>My RectTransform</summary>
		public RectTransform RectTransform => transform as RectTransform;

		public CanvasGroup CanvasGroup
		{
			get
			{
				if (transform.TryGetComponent(out CanvasGroup canvasGroup))
					return canvasGroup;
				return transform.gameObject.AddComponent<CanvasGroup>();
			}
		}

		/// <summary>The first parent Canvas rendering me</summary>
		public Canvas Canvas => transform.GetComponentInParent<Canvas>();

		public AnimationPlayer.AnimatedItem CurrentAnimation { get; set; }

		#region Private fields

		/// <summary>Components cache</summary>
		private Dictionary<(Component, Type), Component> componentCache;

		private VisibleState visibleState = VisibleState.Hidden;

		#endregion

		private void Start()
		{
			AutoSubscribe();
			OnStart();
		}

		/// <summary>
		/// Called after unity Start executed on this.
		/// </summary>
		protected virtual void OnStart()
		{
		}

		private void Awake()
		{
			OnAwake();
		}

		/// <summary>
		/// Called after unity Awake executed on this.
		/// </summary>
		protected virtual void OnAwake()
		{
		}

		/// <summary>Called once when scene loaded. This method is not called for dynamically created views</summary>
		public void Initialize()
		{
			IsDynamicallyCreated = false;
			Owner = transform.parent.GetComponentInParent<BaseView>(true);
			gameObject.SetActive(IsShowAtStart);

			AutoInit();
		}

		protected virtual void AutoInit()
		{
			//this method is overridden in autogenerated script
		}

		protected virtual void AutoSubscribe()
		{
			//this method is overridden in autogenerated script
		}

		public IEnumerable<BaseView> GetMeAndMyOwners()
		{
			yield return this;

			if (Owner != null)
				foreach (var owner in Owner.GetMeAndMyOwners())
					yield return owner;
		}

		/// <summary>OnChanged is automatically called when value of controls was changed by user or buttons were pressed.</summary>
		protected virtual void OnChanged()
		{
		}
		#region Show/Hide

		/// <summary>Show the view</summary>
		public void Show(BaseView owner = null, Action animDoneCallback = null, bool isNoAnimation = false,
			bool concurrentAnimation = false)
		{
			UIManager.Show(this, owner, animDoneCallback, isNoAnimation, concurrentAnimation);
		}

		public void Show()
		{
			UIManager.Show(this, Owner, null, false, false);
		}

		/// <summary>Hide the view and all children views</summary>
		public void Hide(Action animDoneCallback = null, bool isNoAnimation = false, bool concurrentAnimation = false)
		{
			UIManager.Hide(this, animDoneCallback, isNoAnimation, concurrentAnimation);
		}

		/// <summary>Hide the view and all children views</summary>
		public void Hide()
		{
			UIManager.Hide(this, null, false, IsHideChildrenOnHide);
		}

		public void HideAllChildren()
		{
			UIManager.HideAllChildren(this);
		}

		#endregion

		#region ShowCoroutine, ShowAsync

		/// <summary>Shows the view and wait while it will be hidden</summary>
		public IEnumerator ShowCoroutine(BaseView owner, Action animDoneCallback = null, bool isNoAnimation = false)
		{
			Show(owner, animDoneCallback, isNoAnimation);
			while (VisibleState != VisibleState.Hidden)
				yield return null;
		}

		/// <summary>Shows the view and wait while it will be hidden</summary>
		public async Task ShowAsync(BaseView owner, Action animDoneCallback = null, bool isNoAnimation = false)
		{
			Show(owner, animDoneCallback, isNoAnimation);

			await Extensions.WaitUntil(() => VisibleState != VisibleState.Hidden);
		}

		#endregion

		#region Grab components

#if UNITY_EDITOR

		private void Reset()
		{
			GrabComponents(true);
		}

#endif

		/// <summary>Find components inside me and assign to my fields</summary>
		public void GrabComponents(bool forced = false)
		{
			var components = SceneInfoGrabber<BaseView>.GrabInfo(this.transform, false);
			var type = this.GetType();

			foreach (var pair in components)
			{
				var fieldName = pair.Key;
				var fi = type.GetField(fieldName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
				if (fi == null)
				{
					if (SceneInfoGrabber<BaseView>.IsSpecialName(fieldName))
						Debug.LogWarning("<color=#ffff00ff>[FlexUI]</color> Field not found: " + fieldName);
					continue;
				}

				if (!forced) //do not reassign
				{
					var obj = fi.GetValue(this);
					if (obj as UnityEngine.Object != null)
						continue;
				}

				var component = pair.Value;
				var compType = pair.Value.GetType();
				if (fi.FieldType.IsAssignableFrom(compType))
					fi.SetValue(this, component);
				else
					Debug.LogWarning("<color=#ffff00ff>[FlexUI]</color> Type of field is not compatible: " + fieldName);
			}
		}

		internal void GrabViews(Dictionary<string, BaseView> views)
		{
			var type = this.GetType();

			foreach (var pair in views)
			{
				var fieldName = pair.Key;
				var fi = type.GetField(fieldName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
				if (fi == null)
					continue;

				if (fi.GetValue(this) != null) //do not reassign
					continue;

				var component = pair.Value;
				var compType = pair.Value.GetType();
				if (fi.FieldType.IsAssignableFrom(compType))
					fi.SetValue(this, component);
				else
					Debug.LogWarning("<color=#ffff00ff>[FlexUI]</color> Type of field is not compatible: " + fieldName);
			}
		}

		#endregion

		#region Component helpers

		//subscribe Click/OnChanged
		protected void Subscribe(Button bt, Action act)
		{
			bt?.onClick.AddListener(() =>
			{
				act?.Invoke();
			});
		}

		protected void Subscribe(InputField comp, Action<string> act)
		{
			comp?.onValueChanged.AddListener((v) =>
			{
				act?.Invoke(v);
			});
		}

		protected void Subscribe(TMPro.TMP_InputField comp, Action<string> act)
		{
			comp?.onValueChanged.AddListener((v) =>
			{
				act?.Invoke(v);
			});
		}

		protected void Subscribe(Slider comp, Action<float> act)
		{
			comp?.onValueChanged.AddListener((v) =>
			{
				act?.Invoke(v);
			});
		}

		protected void Subscribe(Dropdown comp, Action<int> act)
		{
			comp?.onValueChanged.AddListener((v) =>
			{
				act?.Invoke(v);
			});
		}

		protected void Subscribe(TMPro.TMP_Dropdown comp, Action<int> act)
		{
			comp?.onValueChanged.AddListener((v) =>
			{
				act?.Invoke(v);
			});
		}

		protected void Subscribe(Toggle comp, Action<bool> act)
		{
			comp?.onValueChanged.AddListener((v) =>
			{
				act?.Invoke(v);
			});
		}

		protected void Subscribe(Toggle comp, Action act)
		{
			comp?.onValueChanged.AddListener(v =>
			{
				act.Invoke();
			});
		}

		protected void Subscribe(BaseView view, Action act)
		{
			view.Changed += act;
		}

		protected void Subscribe(Gesture gesture, Action act)
		{
			Gestured += (info) =>
			{
				if (info.Gesture == gesture)
				{
					info.IsHandled = true;
					act();
				}
			};
		}

		//subscribe OnChanged method
		protected void SubscribeOnChanged(Button comp)
		{
			comp?.onClick.AddListener(() =>
			{
				AnyButtonPress(comp);
				if (IsButtonsCallOnChanged) OnChanged();
			});
		}

		protected void SubscribeOnChanged(InputField comp)
		{
			comp.onValueChanged.AddListener((v) =>
			{
				OnChanged();
			});
		}

		protected void SubscribeOnChanged(TMPro.TMP_InputField comp)
		{
			comp?.onValueChanged.AddListener((v) =>
			{
				OnChanged();
			});
		}

		protected void SubscribeOnChanged(Slider comp)
		{
			comp?.onValueChanged.AddListener((v) =>
			{
				OnChanged();
			});
		}

		protected void SubscribeOnChanged(Dropdown comp)
		{
			comp?.onValueChanged.AddListener((v) =>
			{
				OnChanged();
			});
		}

		protected void SubscribeOnChanged(Toggle comp)
		{
			comp?.onValueChanged.AddListener((v) =>
			{
				OnChanged();
			});
		}

		protected void SubscribeOnChanged(Component comp)
		{
			//nothing (this method for autogenerated script)
		}

		//Set color
		protected void Set(Graphic comp, Color color)
		{
			comp.color = color;
		}

		protected void Set(Component comp, Color color)
		{
			var c0 = Get<Image>(comp);
			if (c0) c0.color = color;
			var c1 = Get<RawImage>(comp);
			if (c1) c1.color = color;
		}

		//Set text
		protected void Set(InputField comp, string text)
		{
			comp.SetTextWithoutNotify(text);
		}

		protected void Set(TMPro.TMP_InputField comp, string text)
		{
			comp.SetTextWithoutNotify(text);
		}

		protected void Set(Text comp, string text)
		{
			comp.text = text;
		}

		protected void Set(TMPro.TextMeshProUGUI comp, string text)
		{
			comp.SetText(text);
		}

		protected void Set(TMPro.TextMeshProUGUI comp, int text)
		{
			comp.SetText(text.ToString());
		}

		protected void Set(TMPro.TextMeshProUGUI comp, float text)
		{
			comp.SetText(text.ToString(CultureInfo.InvariantCulture));
		}

		protected void Set(TMPro.TextMeshProUGUI comp, double text)
		{
			comp.SetText(text.ToString(CultureInfo.InvariantCulture));
		}

		protected void Set(Component comp, string text)
		{
			var c1 = Get<TMPro.TextMeshProUGUI>(comp);
			if (c1)
			{
				c1.SetText(text);
				return;
			}

			var c0 = Get<Text>(comp);
			if (c0) c0.text = text;
		}

		//Set bool
		protected void Set(Toggle comp, bool val)
		{
			comp.SetIsOnWithoutNotify(val);
		}

		//Set int
		protected void Set(Slider comp, int val)
		{
			comp.SetValueWithoutNotify(val);
		}

		protected void Set(Dropdown comp, int val)
		{
			comp.SetValueWithoutNotify(val);
		}

		//Set float
		protected void Set(Slider comp, float val)
		{
			comp.SetValueWithoutNotify(val);
		}

		//Set sprite/texture
		protected void Set(Image comp, Sprite sprite)
		{
			comp.sprite = sprite;
		}

		protected void Set(RawImage comp, Texture texture)
		{
			comp.texture = texture;
		}

		protected void Set(Component comp, Sprite sprite)
		{
			var c0 = Get<Image>(comp);
			if (c0) c0.sprite = sprite;
		}

		protected void Set(Component comp, Texture texture)
		{
			var c0 = Get<RawImage>(comp);
			if (c0) c0.texture = texture;
		}

		//set active
		protected void SetActive(Component comp, bool active = true)
		{
			comp.gameObject.SetActive(active);
		}

		//set Interactable
		public void SetInteractable(Selectable comp, bool interactable = true)
		{
			comp.interactable = interactable;
		}

		//get string
		protected string GetString(InputField comp)
		{
			return comp?.text;
		}

		protected string GetString(TMPro.TMP_InputField comp)
		{
			return comp?.text;
		}

		//get float
		protected float GetFloat(Slider comp)
		{
			return comp.value;
		}

		//get int
		protected int GetInt(Dropdown comp)
		{
			return comp.value;
		}

		//get bool
		protected bool GetBool(Toggle comp)
		{
			return comp.isOn;
		}

		/// <summary>Get component of type T (used cache)</summary>
		protected T Get<T>(Component component, bool onlyChildren = false) where T : Component
		{
			if (componentCache == null)
				componentCache = new Dictionary<(Component, Type), Component>();

			var key = (component, typeof(T));

			if (!componentCache.TryGetValue(key, out var comp))
			{
				if (onlyChildren)
					comp = componentCache[key] = component.GetComponentsInChildren<T>(true)
						.FirstOrDefault(c => c.gameObject != component.gameObject);
				else
					comp = componentCache[key] = component.GetComponentInChildren<T>(true);
			}

			return (T)comp;
		}

		#endregion

		#region Instantiate prefabs

		protected new T Instantiate<T>(T prefab) where T : UnityEngine.Object
		{
			if (prefab is BaseView bv)
			{
				//spawn BaseView in same parent
				var res = GameObject.Instantiate(prefab, bv.transform.parent);
				return res;
			}

			//default spawn for other types
			return GameObject.Instantiate(prefab);
		}

		public virtual BaseView Clone()
		{
			return Instantiate(this);
		}

		#endregion

		#region Gestures

		public event Action<GestureInfo> Gestured;

		public void Gesture(GestureInfo info)
		{
			Gestured?.Invoke(info);
			OnGestured(info);
		}

		public virtual void OnGestured(GestureInfo info)
		{
		}

		#endregion

		#region Drag&Drop

		public event Action<BaseView> DragStart;
		public event Action<BaseView, BaseView> Dropped;

		public void DragStarted()
		{
			DragStart?.Invoke(this);
			OnDragStart();
		}

		public void Dropping(BaseView acceptor)
		{
			Dropped?.Invoke(this, acceptor);
			OnDropped(acceptor);
		}

		/// <summary>This method is calling when the view start dragging</summary>
		public virtual void OnDragStart()
		{
		}

		/// <summary>This method is calling when the view is successfully dropped into other view</summary>
		public virtual void OnDropped(BaseView acceptor)
		{
		}

		/// <summary>This method is calling when the view is not accepted and must be destroyed or returned back to starting spot</summary>
		public virtual void OnDropCancelled()
		{
		}

		/// <summary>This method is calling when other view is dragged over the view</summary>
		public virtual bool CanDropIn(BaseView draggedView)
		{
			//override this method and return True if you want to allow drag&drop other view into this view
			return false;
		}

		/// <summary>This method is calling when other view try drop into the view</summary>
		public virtual void DropIn(BaseView draggedView)
		{
		}

		/// <summary>This method is calling when children is moved to other view</summary>
		public virtual void DropOut(BaseView draggedView, BaseView acceptor)
		{
		}

		#endregion

		#region Events

		/// <summary>VisibleState of the view was changed</summary>
		public event Action<VisibleState> VisibleStateChanged;

		/// <summary>View became shown and visible</summary>
		public event Action Shown;

		/// <summary>View became hidden</summary>
		public event Action Hidden;

		/// <summary>Fired when any button of the View is pressed</summary>
		public event Action<Button> AnyButtonPressed;

		private void AnyButtonPress(Button button)
		{
			if (Sounds.PlayButtonClickSound)
				UIManager.PlayButtonSound(this);

			AnyButtonPressed?.Invoke(button);
			OnAnyButtonPressed(button);
		}

		private void VisibleStateChange(VisibleState newState)
		{
			switch (newState)
			{
				case VisibleState.Visible:
					OnShown();
					Shown?.Invoke();
					break;
				case VisibleState.Hidden:
					OnHidden();
					Hidden?.Invoke();
					break;
			}

			VisibleStateChanged?.Invoke(newState);
			OnVisibleStateChanged(newState);
		}

		protected virtual void OnVisibleStateChanged(VisibleState currentState)
		{
		}

		protected virtual void OnShown()
		{
		}

		protected virtual void OnHidden()
		{
		}

		protected virtual void OnAnyButtonPressed(Button button)
		{
		}

		#endregion

		#region IBaseViewInternal

		public void SetVisibleState(VisibleState state)
		{
			if (visibleState != state)
			{
				visibleState = state;
				VisibleStateChange(state);
			}
		}

		public void SetDynamicallyCreated(bool val)
		{
			IsDynamicallyCreated = val;
		}

		#endregion
	}

	[Serializable]
	public class ViewAnimations
	{
		public bool IsOverrideAnimation;
		public AnimationLink ShowAnimation;
		public AnimationLink HideAnimation;
	}

	[Serializable]
	public class ViewSounds
	{
		public bool IsSoundEnabled = false;
		public bool PlayButtonClickSound = true;
		public OwnerSoundMode OwnerMode = OwnerSoundMode.Normal;
		public AudioClip BackgroundSound;
		public bool IsOverrideSounds = false;
		public AudioClip ShowSound;
		public AudioClip HideSound;
	}

	/// <summary>Internal interface of BaseView</summary>
	interface IBaseViewInternal
	{
		void SetVisibleState(VisibleState state);
		void SetDynamicallyCreated(bool val);
	}

	[Serializable]
	public enum DragMode
	{
		Move,
		Copy
	}

	[Serializable]
	public enum VisibleState
	{
		Hidden,
		Visible
	}

	[AttributeUsage(AttributeTargets.Field)]
	public class AutoGeneratedAttribute : Attribute
	{
	}

	[Serializable]
	public enum OwnerSoundMode
	{
		Normal,
		Mute,
		Fade
	}
}