using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;

namespace FlexUI.Editor
{
	static class ScriptBuilder
	{
		public static void CreateScript(RectTransform rt, bool isBuildBaseClass = false,
			bool isAddBaseMethods = false, bool isAddGestureMethods = false, bool isAddDragDropMethods = false)
		{
			if (rt == null)
			{
				FlexLayout.Error($"{rt.name}.cs object is not a RectTransform");
				return;
			}

			if (!rt.TryGetComponent(out BaseView view))
			{
				FlexLayout.Error($"{rt.name}.cs is not a BaseView");
				return;
			}

			var type = view.GetType();
			var baseType = type?.BaseType;
			var baseVariables = GetBaseVariables(baseType);
			var baseNamespace = type?.Namespace;

			if (baseNamespace == null)
			{
				FlexLayout.Error($"{rt.name}.cs has empty namespace");
				return;
			}

			var viewInfo = GrabInfoAboutView(rt);
			if (viewInfo == null)
			{
				FlexLayout.Error($"Grab info of {rt.name}.cs is failed");
				return;
			}

			var filePath = GetOrCreateFile(rt);

			if (string.IsNullOrEmpty(filePath))
				return;

			var template = BuildAutogeneratedTemplate(rt, baseType, viewInfo, baseVariables, baseNamespace);

			var scriptText = Templates.Prepare(template.ToString());

			File.WriteAllText(filePath, scriptText);

			if (isBuildBaseClass)
			{
				template = BuildBaseClassTemplate(rt, baseType, baseNamespace, isAddBaseMethods, isAddGestureMethods, isAddDragDropMethods);
				filePath = GetOrCreateFile(rt, false);
				scriptText = Templates.Prepare(template.ToString());
				File.WriteAllText(filePath, scriptText);
			}

			AssetDatabase.Refresh(ImportAssetOptions.Default);
			Debug.Log($"<color=#ffff00ff>[FlexUI]</color> {rt.name}.cs has been built");

			List<FieldInfo> GetBaseVariables(Type @base)
			{
				var result = new List<FieldInfo>();
				while (@base != null && @base != typeof(BaseView))
				{
					var fieldInfos = @base
						.GetFields(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance)
						.Where(field => field.IsDefined(typeof(AutoGeneratedAttribute), false));

					result.AddRange(fieldInfos);
					@base = @base.BaseType;
				}

				return result;
			}
		}

		private static Template BuildBaseClassTemplate(RectTransform rt, Type baseType, string baseNamespace,
			bool isAddBaseMethods, bool isAddGestureMethods, bool isAddDragDropMethods)
		{
			var templates = Templates.Load();

			var template = GetTemplate("BaseClass");

			template.Add("#CLASSNAME#", rt.name);

			template.Add("#BASECLASS#", baseType?.ToString() ?? "BaseView");

			template.Add("#NAMESPACE#", baseNamespace);

			if (isAddBaseMethods)
			{
				var baseTemplate = GetTemplate("BaseMethods");
				baseTemplate.Add("#CLASSNAME#", rt.name);
				template.Add("#BASEMETHODS#", baseTemplate.ToString());
			}

			if (isAddGestureMethods)
				template.Add("#GESTURES#", GetTemplate("Gestures").ToString());

			if (isAddDragDropMethods)
				template.Add("#DRAGDROP#", GetTemplate("DragDrop").ToString());

			return template;

			Template GetTemplate(string name) => templates.GetTemplate(name);
		}

		private static Template BuildAutogeneratedTemplate(RectTransform rt, Type baseType, ViewInfo viewInfo,
			List<FieldInfo> baseVariables, string baseNamespace)
		{
			var templates = Templates.Load();

			var template = GetTemplate("ViewClass");
			var fieldsTemplate = GetTemplate("Fields");

			// static instance only in base type
			if (baseType == null || baseType == typeof(BaseView))
			{
				template.Add("#INSTANCE#", $"public static {rt.name} Instance {{ get; private set; }}");
				template.Add("#AUTOINIT#", "Instance = this;");
			}
			else
			{
				template.Add("#INSTANCE#", $"public static {rt.name} I => ({rt.name})Instance;");
			}

			//fields
			var wasFields = false;

			foreach (var item in viewInfo.Members.Values)
			{
				if (item.Type == rt.name) // todo: bad comparing with names
					continue; //myself

				if ((item.FieldInfo == null || !item.IsAutogenerated) &&
				    (item.Binded == null || !item.IsAutogenerated) && item.Component == null)
					continue;

				// don't create same vars if they persist in base class
				if (baseVariables.Any(x => x.Name == item.Name))
					continue;

				wasFields = true;
				fieldsTemplate.Add("#FIELDS#", $"    [AutoGenerated, SerializeField] protected {item.Type} {item.Name} = default;");
				template.Add("#INIT#", $"        SubscribeOnChanged({item.Name});");
			}

			if (wasFields)
				template.Add("#FIELDS#", fieldsTemplate.ToString());

			template.Add("#CLASSNAME#", rt.name);

			template.Add("#BASECLASS#", baseType?.ToString() ?? "BaseView");

			template.Add("#NAMESPACE#", baseNamespace);

			return template;

			Template GetTemplate(string name) => templates.GetTemplate(name);
		}

		private static string GetOrCreateFile(RectTransform rt, bool isAutoGenerated = true)
		{
			// Try locating existing script file in project
			var existingScriptsWithSameName = Directory.GetFiles(Application.dataPath, $"{rt.name}.cs", SearchOption.AllDirectories);

			if (existingScriptsWithSameName.Length is 0 or > 2)
			{
				FlexLayout.Error($"Autogenerated {rt.name}.cs has duplicate script");
				return string.Empty;
			}

			if (!isAutoGenerated)
			{
				return existingScriptsWithSameName.FirstOrDefault(file =>
					File.ReadLines(file).Take(5)
						.Any(x => x.IndexOf("THIS IS AUTOGENERATED CODE", StringComparison.OrdinalIgnoreCase) <= 0));
			}

			if (existingScriptsWithSameName.Length == 1)
			{
				var autogeneratedFolder = Path.Combine(Application.dataPath,
					Directory.GetParent(existingScriptsWithSameName[0])!.FullName,
					"_autogenerated");
				if (!Directory.Exists(autogeneratedFolder))
					Directory.CreateDirectory(autogeneratedFolder);

				return Path.Combine(autogeneratedFolder, $"{rt.name}.cs");
			}

			return existingScriptsWithSameName.FirstOrDefault(file =>
				File.ReadLines(file).Take(5).Any(x => x.IndexOf("THIS IS AUTOGENERATED CODE", StringComparison.OrdinalIgnoreCase) > 0));
		}

		private static ViewInfo GrabInfoAboutView(RectTransform rt)
		{
			if (rt == null)
				return null;

			ViewInfo ViewInfo = new ViewInfo();
			ViewInfo.Members.Clear();

			//grab components from scene
			foreach (var info in SceneInfoGrabber<BaseView>.GrabInfo(rt, false))
				ViewInfo.Members[info.Key] = new ViewInfoItem { Name = info.Key, Component = info.Value };

			//grab exists fileds
			Type viewType = null;
			var view = rt.GetComponent<BaseView>();
			if (view != null)
				viewType = view.GetType();

			if (viewType != null)
			{
				var fields = viewType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance |
				                                BindingFlags.DeclaredOnly);
				foreach (var fi in fields)
				{
					if (SceneInfoGrabber<BaseView>.WellKnownTypes.Contains(fi.FieldType) || typeof(BaseView).IsAssignableFrom(fi.FieldType))
					{
						var isAutogenerated = fi.GetCustomAttribute<AutoGeneratedAttribute>();
						if (isAutogenerated != null)
						{
							//skip isAutogenerated fields => they will recreated
							continue;
						}

						ViewInfo.Members[fi.Name] = new ViewInfoItem { Name = fi.Name, FieldInfo = fi };
					}
				}
			}

			return ViewInfo;
		}

		public static void RemoveScript(RectTransform rt)
		{
			var existingScriptsWithSameName = Directory.GetFiles(Application.dataPath, $"{rt.name}.cs", SearchOption.AllDirectories);
			if (existingScriptsWithSameName.Length != 2)
				return;

			var filePath = existingScriptsWithSameName.FirstOrDefault(file =>
				File.ReadLines(file).Take(10).Any(x => x.IndexOf("autogen", StringComparison.OrdinalIgnoreCase) >= 0));

			if (filePath == null)
				return;

			File.Delete(filePath);
			File.Delete(filePath + ".meta");

			var directory = Directory.GetParent(filePath);
			if (directory != null && Directory.GetFiles(directory.FullName).Count(x => !x.EndsWith(".meta")) == 0)
			{
				var meta = Directory.GetFiles(Directory.GetParent(directory.FullName)!.FullName, $"{directory.Name}.meta",
					SearchOption.TopDirectoryOnly);
				Directory.Delete(directory.FullName);
				if (meta.Length == 1)
					File.Delete(meta[0]);
			}

			Debug.Log($"<color=#ffff00ff>[FlexUI]</color> Autogenerated script {rt.name}.cs has been deleted");
			AssetDatabase.Refresh(ImportAssetOptions.Default);
		}
	}

	// public class Argument
	// {
	// 	public string Type;
	// 	public string Name;
	// 	public string DefaultValue;
	//
	// 	public static IEnumerable<Argument> Parse(string signature)
	// 	{
	// 		if (string.IsNullOrWhiteSpace(signature))
	// 			yield break;
	//
	// 		var parts = (signature ?? "").Split(',');
	// 		foreach (var part in parts)
	// 		{
	// 			var parts2 = part.Trim().Split('=');
	// 			var parts3 = parts2[0].Trim().Split(' ');
	// 			string defaultVal = null;
	// 			if (parts2.Length > 1)
	// 				defaultVal = parts2[1].Trim();
	//
	// 			if (parts3.Length == 2)
	// 				yield return new Argument { Name = parts3[1], Type = parts3[0], DefaultValue = defaultVal };
	// 		}
	// 	}

	// static readonly HashSet<string> WELL_KNOWN_TYPES = new HashSet<string>();

	// static Argument()
	// {
	// 	GrabTypes(typeof(string).Assembly);
	// 	GrabTypes(typeof(Vector2).Assembly);
	//
	// 	WELL_KNOWN_TYPES.Add("string");
	// 	WELL_KNOWN_TYPES.Add("int");
	// 	WELL_KNOWN_TYPES.Add("float");
	// 	WELL_KNOWN_TYPES.Add("double");
	// 	WELL_KNOWN_TYPES.Add("byte");
	// 	WELL_KNOWN_TYPES.Add("decimal");
	// 	WELL_KNOWN_TYPES.Add("char");
	// 	WELL_KNOWN_TYPES.Add("bool");
	// }

	// static void GrabTypes(Assembly ass)
	// {
	// 	foreach (var type in ass.GetTypes().Select(t => t.Name.ToLower()))
	// 		WELL_KNOWN_TYPES.Add(type);
	// }
	//
	// public bool CheckIsTypeExists()
	// {
	// 	var parts = Type.Split('.');
	// 	var lastPart = parts[parts.Length - 1].ToLower();
	// 	var bracketIndex = lastPart.IndexOf('[');
	// 	if (bracketIndex >= 0)
	// 		lastPart = lastPart.Substring(0, bracketIndex);
	//
	// 	if (WELL_KNOWN_TYPES.Contains(lastPart))
	// 		return true;
	//
	// 	return false;
	// 	// return UIGraphEditor.GetTypeByName(Type, "") != null;
	// }
	// }

	public class ViewInfo
	{
		public Dictionary<string, ViewInfoItem> Members = new Dictionary<string, ViewInfoItem>();
	}

	public class ViewInfoItem
	{
		public string Name;
		public Component Component;
		public FieldInfo FieldInfo;
		public MethodInfo MethodInfo;
		public string Binded;
		public bool IsAutogenerated;
		public bool IsAutogeneratedReallyExists;

		public string Type => Component != null
			? Component.GetType().FullName
			: (FieldInfo != null ? FieldInfo.FieldType.FullName : Binded ?? "void");
	}
}